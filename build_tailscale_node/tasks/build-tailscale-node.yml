# tasks/apt.yml
- name: Install apt packages
  ansible.builtin.apt:
    pkg:
      - aide
      - auditd
      - chkrootkit
      - cryptsetup
      - easy-rsa
      - libpam-google-authenticator
      - qrencode
      - resolvconf
      - rkhunter
      - tmux
      - wireguard
    update_cache: yes
    install_recommends: no
  when: ansible_facts['os_family'] == "Debian"
  become: yes
  become_method: sudo

# tasks/dnf.yml
- name: Install dnf packages
  ansible.builtin.dnf:
    pkg:
      - aide
      - audit
      - chkrootkit
      - cryptsetup
      - easy-rsa
      - firewalld
      - google-authenticator
      - qrencode
      - resolvconf
      - rkhunter
      - tmux
      - tcpdump
      - wireguard-tools
    update_cache: yes
  when: ansible_facts['os_family'] == "RedHat"
  become: yes
  become_method: sudo

# tasks/cron.yml
- name: Disable cron tasks for IDS packages
  ansible.builtin.shell:
    cmd: for crontask in aide chkrootkit rkhunter; do find /etc/cron* -name "$crontask" -print0 | xargs -0 sudo chmod -x 2>/dev/null; done
  ignore_errors: true
  become: yes
  become_method: sudo

# tasks/firewall.yml
- name: Configure ufw rules for Debian/Ubuntu
  ansible.builtin.shell: |
    sudo ufw allow ssh;
    echo 'y' | sudo ufw enable;
  args:
    executable: /bin/bash
  when: ansible_facts['os_family'] == "Debian"
  become: yes
  become_method: sudo

- name: Configure firewalld rules for RedHat/Fedora
  ansible.builtin.shell: |
    sudo systemctl unmask firewalld;
    sudo systemctl start firewalld;
    sudo systemctl enable firewalld;
  args:
    executable: /bin/bash
  when: ansible_facts['os_family'] == "RedHat"
  become: yes
  become_method: sudo

# tasks/forwarding.yml
# https://docs.ansible.com/ansible/latest/collections/ansible/builtin/stat_module.html
# https://stackoverflow.com/questions/35654286/how-to-check-if-a-file-exists-in-ansible
- name: Check sysctl path
  ansible.builtin.stat:
    path: /etc/sysctl.d
  register: etc_sysctl_d_exists

- name: Configure packet forwarding in the kernel (/etc/sysctl.d/99-tailscale.conf)
  ansible.builtin.copy:
    content: |
      net.ipv4.ip_forward = 1
      net.ipv6.conf.all.forwarding = 1
    dest: /etc/sysctl.d/99-tailscale.conf
    owner: root
    group: root
    mode: '0644'
  when: is_exit_node == "True" and etc_sysctl_d_exists.stat.isdir is defined and etc_sysctl_d_exists.stat.isdir
  become: yes
  become_method: sudo

- name: Enable packet forwarding in the kernel (/etc/sysctl.d/99-tailscale.conf)
  ansible.builtin.shell: |
    sudo sysctl -p /etc/sysctl.d/99-tailscale.conf
  args:
    executable: /bin/bash
  when: is_exit_node == "True" and etc_sysctl_d_exists.stat.isdir is defined and etc_sysctl_d_exists.stat.isdir
  become: yes
  become_method: sudo

# Use for /etc/sysctl.conf
#  when: etc_sysctl_d_exists.stat.isdir is not defined and etc_sysctl_d_exists.stat.isdir == False

- name: Allow masquerading in firewalld
  ansible.builtin.shell: |
    sudo firewall-cmd --permanent --add-masquerade
  args:
    executable: /bin/bash
  when: is_exit_node == "True" and ansible_facts['os_family'] == "RedHat"
  become: yes
  become_method: sudo

# tasks/tailscale.yml
# This handles installing and running tailscale
# The install.sh script is included in this role under the BSD-3 license for security, instead of using `curl ... | bash -` as root
- name: Copy tailscale-installer.sh to target
  ansible.builtin.copy:
    src: "{{ item.src }}"
    dest: "{{ item.dest }}"
    owner: root
    group: root
    mode: '0755'
  with_items:
    - { src: 'tailscale-installer.sh', dest: '/usr/local/bin/tailscale-installer.sh' }
  become: yes
  become_method: sudo

- name: Check if tailscale is already installed
  ansible.builtin.shell: |
    command -v tailscale
  args:
    executable: /bin/bash
  register: tailscale_install_path
  ignore_errors: true

- name: Install tailscale (using installer.sh)
  ansible.builtin.shell:
    cmd: /usr/local/bin/tailscale-installer.sh
  when: tailscale_install_path.stdout == ""
  become: yes
  become_method: sudo

- name: Check if tailscale is already authenticated to a tailnet
  ansible.builtin.shell: |
    tailscale ip
  args:
    executable: /bin/bash
  register: tailscale_auth_check
  when: tailscale_install_path.stdout != ""
  ignore_errors: true
  become: yes
  become_method: sudo

# Write the value of tailscale_authkey in an ansible-vault encrypted auth.yml file
- name: Authenticate node to tailnet
  ansible.builtin.shell: |
    sudo tailscale up --authkey {{ tailscale_authkey }}
  args:
    executable: /bin/bash
  when: tailscale_authkey != "" and tailscale_auth_check.stderr.find("NeedsLogin") != -1
  become: yes
  become_method: sudo

# Advertise as exit node
- name: Advertise as exit node
  ansible.builtin.shell: |
    sudo tailscale up --advertise-exit-node
  args:
    executable: /bin/bash
  when: is_exit_node == "True"
  become: yes
  become_method: sudo

# tasks/pcap-service.yml
# Only starts if `pcap_service_enable` set to `true` in vars/main.yml
- name: Add pcap-service scripts to server's /usr/local/bin/ path
  ansible.builtin.copy:
    src: "{{ item.src }}"
    dest: "{{ item.dest }}"
    owner: root
    group: root
    mode: '0755'
  with_items:
    - { src: 'pcap-service.sh', dest: '/usr/local/bin/pcap-service.sh' }
  become: yes
  become_method: sudo

- name: Register if pcap-service is enabled
  ansible.builtin.shell: systemctl is-enabled packet-capture.service
  register: pcap_service_status
  ignore_errors: true

- name: Start pcap-service network monitoring
  ansible.builtin.shell:
    cmd: /usr/local/bin/pcap-service.sh
  environment:
    PCAP_PATH: "{{ pcap_service_pcap_path }}"
    CAP_IFACE_CHOICE: "{{ pcap_service_cap_iface }}"
    DAYS: "{{ pcap_service_retention_days }}"
  when: pcap_service_status.stdout != 'enabled' and pcap_service_enable == "True"
  become: yes
  become_method: sudo

# tasks/unbound-acl.yml
# Only runs if unbound is installed and enabled
- name: Register if unbound is enabled
  ansible.builtin.shell: systemctl is-enabled unbound
  register: unbound_status
  ignore_errors: true

#- name: Add tailscale CGNAT range to unbound acl list
#  ansible.builtin.shell: |
#    echo "server:" > /etc/unbound/unbound.conf.d/unbound-acl.conf
#    echo "        interface: {TO DO}" >> /etc/unbound/unbound.conf.d/unbound-acl.conf
#    echo "        interface: {TO DO} >> /etc/unbound/unbound.conf.d/unbound-acl.conf
#    echo "        access-control: 100.64.0.0/10 allow" >> /etc/unbound/unbound.conf.d/unbound-acl.conf
#    echo "        access-control: {TO DO} allow" >> /etc/unbound/unbound.conf.d/unbound-acl.conf
#  args:
#    executable: /bin/bash
#  when: unbound_status.stdout == 'enabled'
#  notify: Restart Unbound
#  become: yes
#  become_method: sudo